// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract MyShop {
    // Устанавливаем в переменной нашего класса переменную владельца 
    // address - встроенный метод которыый должен содержать данные о владельце смартконтракта
    address public owner;

    // mapping - подобие массва, address - ключ, uint - целочисленное не отрицательное значение
    mapping (address => uint) public payments;

    // Вызовется автоматически 1 раз когда смарт-контракт будет помещен в блокчейн 
    constructor() {
        // В конструкторе необходимо присвоить переменной значения
        // msg - глобальный обьект(тот кто шлет транзакцию)
        // sender - свойство возвращающая адрес отправителя
        owner = msg.sender;
        // За хранение переменных в области памяти смрат-контракта необходимо платить
    }

    // public - Чтобы функцию могли вызывать из-вне покупатели необходимо сделать ее публичной
    // payable - модификатор который указывае на функции которые предназначение для отправки денег, если его не указать деньги будут отправлены обратно отправителю
    function payForItem() public payable {
        // По сути в теле функции больше ничего писать нет необходимочсти
        // поскольку уже указан модификатор и при обращении к данной ф-ции средства будут зачислены на адрес указаный в смартконтракте

        // Записываем кто нам перевекл и сколько, это адрес клиента которые вызывают функцию чтобы совершить транзакцию
        // msg.sender - всегда непосредственный инициатор транзакции.
        // Создание контракта - тоже транзакция, так что в этот момент в msg.sender будет адрес создателя.
        // Последующие вызовы функций могут делать другие люди (аккаунты) и соответственно msg.sender будет содержать их адреса.
        // То есть это значение строго зависит от того, кто делает конкретную транзакцию
        payments[msg.sender] = msg.value;
    }

    // Фуекция для списания всех денежных средств на счет владельца
    function withdrawAll() public {
        // Поскольку наш owner не помечен как payable создаем временную переменную 
        // которая равна owner помеченый модификатором payable
        address payable _to = payable(owner);
        // Вытаксиваем данные о количестве накопившейся валюты
        address _thisContract = address(this);
        _to.transfer(_thisContract.balance);
    }
}


// 0xd9145CCE52D386f254917e481eB44e9943F39138
// Final address smart contract